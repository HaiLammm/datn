# Story 7.4: Thông báo tin nhắn Real-time

Status: ready-for-dev

## Epic
Epic 7: Trò chuyện Trực tuyến (Real-time Messaging with Socket.io)

## Story

As a **User** (both Recruiter and Candidate),
I want to **receive real-time notifications when new messages arrive**,
so that **I don't miss important communications and can respond promptly**.

## Acceptance Criteria

1. User must see a **toast notification** when a new message arrives while NOT on the conversation page
2. Toast notification must display sender's name and message preview (first 50 chars)
3. Clicking toast notification must navigate user to the conversation
4. Navigation menu must display **unread count badge** showing total unread messages
5. Badge must update in real-time when new messages arrive or when messages are marked as read
6. User must see **typing indicator** ("X is typing...") when other participant is typing
7. Typing indicator must appear within 500ms of other user starting to type
8. Typing indicator must disappear when other user stops typing (3-second timeout)
9. User must see **connection status indicator** (green = connected, red = disconnected)
10. Connection status must update immediately when Socket.io connection changes

## Tasks / Subtasks

### Backend Tasks - Socket.io Typing Events

- [ ] **Typing Indicator Events** (AC: 6, 7, 8)
  - [ ] Add `typing-start` event handler in `socket-server/handlers/message.js`
  - [ ] When received, broadcast `user-typing` event to conversation room (exclude sender)
  - [ ] Event payload: `{ conversation_id, user_id, user_name }`
  - [ ] Add `typing-stop` event handler
  - [ ] When received, broadcast `user-stopped-typing` event to conversation room
  - [ ] Event payload: `{ conversation_id, user_id }`

- [ ] **Typing Indicator Auto-Timeout** (AC: 8)
  - [ ] Implement server-side timeout tracking
  - [ ] Store typing users in memory: `Map<conversationId, Map<userId, timeoutId>>`
  - [ ] Set 5-second server timeout when `typing-start` received
  - [ ] Clear timeout if `typing-stop` received before timeout
  - [ ] Auto-emit `user-stopped-typing` if timeout expires
  - [ ] Prevents stuck typing indicators if client disconnects

- [ ] **Connection Status Events** (AC: 9, 10)
  - [ ] Socket.io automatically handles `connect` and `disconnect` events
  - [ ] No additional backend code needed
  - [ ] Frontend listens to these built-in events

- [ ] **Optimize Event Broadcasting** (AC: 7)
  - [ ] Typing events should NOT be persisted to database
  - [ ] Use in-memory broadcasting only
  - [ ] Target latency: <200ms for typing indicator

### Frontend Tasks - Toast Notifications

- [ ] **Toast Notification Library Setup** (AC: 1, 2, 3)
  - [ ] Install Sonner library: `npm install sonner`
  - [ ] Add `<Toaster />` component to `frontend/app/layout.tsx`
  - [ ] Configure toast position: bottom-right
  - [ ] Configure toast duration: 4 seconds

- [ ] **Global Message Notification Listener** (AC: 1, 2, 3)
  - [ ] Extend `useGlobalSocket` hook from Story 7.3
  - [ ] Listen to `new-message` event from user room (`user:${userId}`)
  - [ ] Check if user is currently on the conversation page
  - [ ] If NOT on conversation page, show toast notification
  - [ ] Toast content: `{sender_name}: {message_content.substring(0, 50)}...`
  - [ ] Toast action: onClick navigate to `/messages/${conversationId}`

- [ ] **Smart Toast Display Logic** (AC: 1)
  - [ ] Use `usePathname()` from Next.js to get current route
  - [ ] Don't show toast if on `/messages/${conversationId}` (already seeing message)
  - [ ] Show toast if on different conversation or different page entirely
  - [ ] Show toast if user is on conversation list (`/messages`) but not in specific conversation

### Frontend Tasks - Unread Count Badge

- [ ] **Navigation Badge Component** (AC: 4, 5)
  - [ ] Create `frontend/components/layout/MessagesBadge.tsx`
  - [ ] Use conversation list context from Story 7.3
  - [ ] Calculate total unread: `conversations.reduce((sum, conv) => sum + conv.unread_count, 0)`
  - [ ] Display red badge with number if unread count > 0
  - [ ] Hide badge if unread count === 0
  - [ ] Max display: 99+ (if count > 99, show "99+")

- [ ] **Real-time Badge Updates** (AC: 5)
  - [ ] Badge automatically updates when conversation list context changes
  - [ ] Context updates via `conversation-updated` Socket.io event (from Story 7.3)
  - [ ] Badge decrements when user opens conversation (mark as read from Story 7.3)
  - [ ] No additional Socket.io events needed

- [ ] **Navigation Menu Integration** (AC: 4)
  - [ ] Add MessagesBadge component to navigation menu
  - [ ] Position badge on top-right of Messages icon
  - [ ] Use absolute positioning with top-[-8px] right-[-8px]
  - [ ] Badge should be visible on all pages

### Frontend Tasks - Typing Indicator

- [ ] **Typing Detection Hook** (AC: 6, 7, 8)
  - [ ] Create `frontend/hooks/useTypingIndicator.ts`
  - [ ] Track local typing state (is current user typing?)
  - [ ] Track remote typing state (is other user typing?)
  - [ ] Emit `typing-start` when user starts typing (debounced 300ms)
  - [ ] Emit `typing-stop` when user stops typing (debounced 3 seconds)
  - [ ] Listen to `user-typing` event to show indicator
  - [ ] Listen to `user-stopped-typing` event to hide indicator

- [ ] **Typing Indicator Component** (AC: 6, 7, 8)
  - [ ] Create `frontend/features/messages/components/TypingIndicator.tsx`
  - [ ] Display: "{user_name} is typing..." with animated dots
  - [ ] Animate dots: "..." → ".  " → " . " → "  ." (cycle every 500ms)
  - [ ] Position above message input area
  - [ ] Show only when remote typing state is true
  - [ ] Hide with fade-out animation (200ms transition)

- [ ] **Message Input Integration** (AC: 6, 7, 8)
  - [ ] Update `MessageInput.tsx` to use `useTypingIndicator` hook
  - [ ] On input onChange:
    - If first character typed, emit `typing-start` immediately
    - If continue typing, debounce 300ms before emitting `typing-start` again
  - [ ] On input empty or 3 seconds no typing, emit `typing-stop`
  - [ ] On message send, emit `typing-stop` immediately
  - [ ] Clear local typing state when message sent

- [ ] **Debounce Strategy** (AC: 7, 8)
  - [ ] Use lodash.debounce or custom debounce hook
  - [ ] Typing start debounce: 300ms (avoid spamming events on every keystroke)
  - [ ] Typing stop debounce: 3000ms (3 seconds of inactivity)
  - [ ] Cancel debounce timers on component unmount
  - [ ] Cancel typing-stop timer when new keystroke detected

### Frontend Tasks - Connection Status Indicator

- [ ] **Connection Status Component** (AC: 9, 10)
  - [ ] Create `frontend/features/messages/components/ConnectionStatus.tsx`
  - [ ] Display small badge: "Connected" (green) or "Disconnected" (red)
  - [ ] Use Socket.io `isConnected` state from `useSocket` or `useGlobalSocket` hook
  - [ ] Position: Top-right corner of chat window or conversation list
  - [ ] Auto-hide "Connected" badge after 2 seconds (only show on reconnect)
  - [ ] Always show "Disconnected" badge until reconnected

- [ ] **Socket Connection State Tracking** (AC: 9, 10)
  - [ ] Extend `useSocket` hook to expose `isConnected` state
  - [ ] Listen to Socket.io `connect` event → set isConnected = true
  - [ ] Listen to Socket.io `disconnect` event → set isConnected = false
  - [ ] Listen to Socket.io `connect_error` event → set isConnected = false
  - [ ] Provide connection status to ConnectionStatus component

- [ ] **Reconnection Handling** (AC: 10)
  - [ ] Socket.io automatically handles reconnection (exponential backoff)
  - [ ] On reconnect, re-join conversation rooms automatically
  - [ ] On reconnect, re-fetch missed messages (call REST API)
  - [ ] Show success toast: "Reconnected" when connection restored
  - [ ] Fetch messages since last known timestamp

### Testing Tasks

- [ ] **Toast Notification Tests** (AC: 1, 2, 3)
  - [ ] Test toast appears when message received on different page
  - [ ] Test toast does NOT appear when on active conversation page
  - [ ] Test toast shows correct sender name and message preview
  - [ ] Test clicking toast navigates to conversation
  - [ ] Test multiple toasts stack properly (multiple conversations)

- [ ] **Unread Badge Tests** (AC: 4, 5)
  - [ ] Test badge displays correct unread count
  - [ ] Test badge updates in real-time when new message arrives
  - [ ] Test badge decrements when conversation opened
  - [ ] Test badge shows "99+" when count > 99
  - [ ] Test badge hidden when unread count = 0

- [ ] **Typing Indicator Tests** (AC: 6, 7, 8)
  - [ ] Test typing indicator appears when other user starts typing
  - [ ] Test typing indicator appears within 500ms
  - [ ] Test typing indicator disappears when other user stops typing
  - [ ] Test typing indicator disappears after 3-second timeout
  - [ ] Test typing indicator does NOT show for own typing
  - [ ] Test typing indicator works bidirectionally

- [ ] **Connection Status Tests** (AC: 9, 10)
  - [ ] Test connection badge shows "Connected" on initial connection
  - [ ] Test connection badge shows "Disconnected" when connection lost
  - [ ] Test connection badge updates immediately on state change
  - [ ] Test reconnection flow (disconnect → reconnect → re-join rooms)
  - [ ] Test missed messages fetched on reconnection

- [ ] **E2E Test** (AC: All)
  - [ ] Test full flow:
    1. User A and User B in separate conversations
    2. User B sends message to User A
    3. User A (on different page) sees toast notification
    4. User A sees navigation badge increment
    5. User A clicks toast → navigates to conversation
    6. User A sees message, badge decrements
    7. User A starts typing → User B sees typing indicator
    8. User A sends message → typing indicator disappears
  - [ ] Verify all features work together seamlessly

## Dev Notes

### Architecture: Real-time Notifications with Socket.io

**Key Point:** Story 7.4 adds the **final layer of real-time UX polish** to the messaging system. It leverages Socket.io events from Stories 7.1-7.3 to provide instant feedback to users without page refreshes.

### Socket.io Event Flow Diagram

```
Frontend (User A)                    Socket.io Server                    Frontend (User B)
─────────────────                    ────────────────                    ─────────────────

[Typing in input]
     │
     ├─ onChange event
     │
     ├─ Debounce 300ms
     │
     └─> emit('typing-start', { conversationId })
                                          │
                                          ├─ Broadcast to conversation room
                                          │  (exclude sender)
                                          │
                                          └─> emit('user-typing', {
                                                  conversation_id,
                                                  user_id,
                                                  user_name
                                              })
                                                                               │
                                                                               ├─ Show typing indicator
                                                                               └─ "Alice is typing..."

[Stop typing for 3s]
     │
     └─> emit('typing-stop', { conversationId })
                                          │
                                          └─> emit('user-stopped-typing', {
                                                  conversation_id,
                                                  user_id
                                              })
                                                                               │
                                                                               └─ Hide typing indicator

[On different page]
                                          │
                                 New message arrives
                                          │
                                          ├─ emit('new-message') to conversation room
                                          │
                                          └─> emit('conversation-updated') to user room
                                                                               │
                                                                               ├─ Check: on conversation page?
                                                                               │    NO
                                                                               │
                                                                               └─ Show toast notification
                                                                                  "Alice: Hello, are you..."
```

### Typing Indicator Implementation

**Frontend Typing Detection:**

```typescript
// frontend/hooks/useTypingIndicator.ts

import { useEffect, useRef, useCallback } from 'react';
import { Socket } from 'socket.io-client';
import { debounce } from 'lodash';

export function useTypingIndicator(
  socket: Socket | null,
  conversationId: string
) {
  const [isTyping, setIsTyping] = useState(false);
  const [typingUser, setTypingUser] = useState<{ id: string; name: string } | null>(null);

  const typingStopTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  // Emit typing-start (debounced to avoid spamming)
  const emitTypingStart = useCallback(
    debounce(() => {
      if (socket?.connected) {
        socket.emit('typing-start', { conversationId });
        setIsTyping(true);
      }
    }, 300),
    [socket, conversationId]
  );

  // Emit typing-stop
  const emitTypingStop = useCallback(() => {
    if (socket?.connected) {
      socket.emit('typing-stop', { conversationId });
      setIsTyping(false);
    }
  }, [socket, conversationId]);

  // Handle input change
  const handleTyping = useCallback(() => {
    emitTypingStart();

    // Clear existing timeout
    if (typingStopTimeoutRef.current) {
      clearTimeout(typingStopTimeoutRef.current);
    }

    // Set new timeout: emit typing-stop after 3 seconds of inactivity
    typingStopTimeoutRef.current = setTimeout(() => {
      emitTypingStop();
    }, 3000);
  }, [emitTypingStart, emitTypingStop]);

  // Listen to typing events from other user
  useEffect(() => {
    if (!socket) return;

    socket.on('user-typing', (data: { user_id: string; user_name: string }) => {
      setTypingUser({ id: data.user_id, name: data.user_name });
    });

    socket.on('user-stopped-typing', (data: { user_id: string }) => {
      setTypingUser(null);
    });

    return () => {
      socket.off('user-typing');
      socket.off('user-stopped-typing');
    };
  }, [socket]);

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      if (typingStopTimeoutRef.current) {
        clearTimeout(typingStopTimeoutRef.current);
      }
      emitTypingStop();
    };
  }, [emitTypingStop]);

  return {
    isTyping, // Is current user typing?
    typingUser, // Other user typing info
    handleTyping, // Call on input onChange
    emitTypingStop // Call on message send
  };
}
```

**Backend Typing Event Handler:**

```javascript
// socket-server/handlers/typing.js

const typingUsers = new Map(); // Map<conversationId, Map<userId, timeoutId>>

function handleTypingEvents(io, socket) {
  socket.on('typing-start', ({ conversationId }) => {
    // Broadcast to conversation room (exclude sender)
    socket.to(`conversation:${conversationId}`).emit('user-typing', {
      conversation_id: conversationId,
      user_id: socket.userId,
      user_name: socket.userName
    });

    // Server-side timeout: auto-emit typing-stop after 5 seconds
    if (!typingUsers.has(conversationId)) {
      typingUsers.set(conversationId, new Map());
    }

    const conversationTyping = typingUsers.get(conversationId);

    // Clear existing timeout
    if (conversationTyping.has(socket.userId)) {
      clearTimeout(conversationTyping.get(socket.userId));
    }

    // Set new timeout
    const timeoutId = setTimeout(() => {
      socket.to(`conversation:${conversationId}`).emit('user-stopped-typing', {
        conversation_id: conversationId,
        user_id: socket.userId
      });
      conversationTyping.delete(socket.userId);
    }, 5000);

    conversationTyping.set(socket.userId, timeoutId);
  });

  socket.on('typing-stop', ({ conversationId }) => {
    socket.to(`conversation:${conversationId}`).emit('user-stopped-typing', {
      conversation_id: conversationId,
      user_id: socket.userId
    });

    // Clear server timeout
    if (typingUsers.has(conversationId)) {
      const conversationTyping = typingUsers.get(conversationId);
      if (conversationTyping.has(socket.userId)) {
        clearTimeout(conversationTyping.get(socket.userId));
        conversationTyping.delete(socket.userId);
      }
    }
  });

  // Cleanup on disconnect
  socket.on('disconnect', () => {
    // Emit typing-stop for all conversations this user was typing in
    typingUsers.forEach((conversationTyping, conversationId) => {
      if (conversationTyping.has(socket.userId)) {
        clearTimeout(conversationTyping.get(socket.userId));
        conversationTyping.delete(socket.userId);

        io.to(`conversation:${conversationId}`).emit('user-stopped-typing', {
          conversation_id: conversationId,
          user_id: socket.userId
        });
      }
    });
  });
}

module.exports = { handleTypingEvents };
```

### Toast Notification System

**Using Sonner Library (Recommended):**

```typescript
// frontend/app/layout.tsx

import { Toaster } from 'sonner';

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en">
      <body>
        {children}
        <Toaster position="bottom-right" duration={4000} />
      </body>
    </html>
  );
}
```

**Global Toast Listener:**

```typescript
// frontend/hooks/useGlobalSocket.ts (extended from Story 7.3)

import { toast } from 'sonner';
import { usePathname, useRouter } from 'next/navigation';

export function useGlobalSocket() {
  const [socket, setSocket] = useState<Socket | null>(null);
  const pathname = usePathname();
  const router = useRouter();

  useEffect(() => {
    const token = getAuthToken();
    const newSocket = io(process.env.NEXT_PUBLIC_SOCKET_URL!, {
      auth: { token }
    });

    newSocket.on('connect', () => {
      console.log('Global socket connected');
    });

    // NEW: Toast notification on new message
    newSocket.on('conversation-updated', (data) => {
      // Check if user is on the conversation page
      const isOnConversationPage = pathname === `/messages/${data.conversation_id}`;

      if (!isOnConversationPage) {
        // Show toast notification
        toast(`${data.last_message.sender_name}: ${data.last_message.content.substring(0, 50)}${data.last_message.content.length > 50 ? '...' : ''}`, {
          action: {
            label: 'View',
            onClick: () => router.push(`/messages/${data.conversation_id}`)
          }
        });
      }
    });

    setSocket(newSocket);

    return () => newSocket.close();
  }, [pathname, router]);

  return socket;
}
```

### Unread Count Badge

**Navigation Badge Component:**

```typescript
// frontend/components/layout/MessagesBadge.tsx

import { useConversations } from '@/contexts/ConversationsContext'; // From Story 7.3

export function MessagesBadge() {
  const { conversations } = useConversations();

  const totalUnread = conversations.reduce((sum, conv) => sum + conv.unread_count, 0);

  if (totalUnread === 0) return null;

  const displayCount = totalUnread > 99 ? '99+' : totalUnread.toString();

  return (
    <div className="absolute top-[-8px] right-[-8px] bg-red-500 text-white text-xs font-bold rounded-full min-w-[20px] h-5 flex items-center justify-center px-1.5">
      {displayCount}
    </div>
  );
}
```

**Navigation Menu Integration:**

```typescript
// frontend/components/layout/Navigation.tsx

import { MessagesBadge } from './MessagesBadge';

export function Navigation() {
  return (
    <nav>
      {/* Other nav items */}

      <Link href="/messages" className="relative">
        <MessageIcon />
        <MessagesBadge />
      </Link>
    </nav>
  );
}
```

### Connection Status Indicator

**Connection Status Component:**

```typescript
// frontend/features/messages/components/ConnectionStatus.tsx

import { useSocket } from '@/hooks/useSocket';
import { useEffect, useState } from 'react';

export function ConnectionStatus({ conversationId }: { conversationId?: string }) {
  const { isConnected } = useSocket(conversationId);
  const [showConnected, setShowConnected] = useState(false);
  const [wasDisconnected, setWasDisconnected] = useState(false);

  useEffect(() => {
    if (isConnected) {
      // Show "Connected" badge only if we were previously disconnected
      if (wasDisconnected) {
        setShowConnected(true);

        // Auto-hide after 2 seconds
        const timeout = setTimeout(() => {
          setShowConnected(false);
          setWasDisconnected(false);
        }, 2000);

        return () => clearTimeout(timeout);
      }
    } else {
      // Disconnected
      setWasDisconnected(true);
    }
  }, [isConnected, wasDisconnected]);

  if (isConnected && !showConnected) return null;

  return (
    <div
      className={`
        fixed top-4 right-4 px-3 py-2 rounded-lg text-sm font-medium
        flex items-center gap-2 shadow-lg z-50
        ${isConnected ? 'bg-green-500 text-white' : 'bg-red-500 text-white'}
      `}
    >
      <div className={`w-2 h-2 rounded-full ${isConnected ? 'bg-white' : 'bg-white animate-pulse'}`} />
      {isConnected ? 'Connected' : 'Disconnected'}
    </div>
  );
}
```

**Reconnection Logic:**

```typescript
// frontend/hooks/useSocket.ts (extended from Story 7.1)

export function useSocket(conversationId: string) {
  const [socket, setSocket] = useState<Socket | null>(null);
  const [messages, setMessages] = useState<Message[]>([]);
  const [isConnected, setIsConnected] = useState(false);
  const lastMessageTimeRef = useRef<string | null>(null);

  useEffect(() => {
    const token = getAuthToken();
    const newSocket = io(process.env.NEXT_PUBLIC_SOCKET_URL!, {
      auth: { token },
      transports: ['websocket', 'polling']
    });

    newSocket.on('connect', () => {
      console.log('Socket connected');
      setIsConnected(true);

      // Re-join conversation room on reconnect
      newSocket.emit('join-conversation', conversationId);

      // Fetch missed messages since last known timestamp
      if (lastMessageTimeRef.current) {
        fetchMissedMessages(conversationId, lastMessageTimeRef.current).then(missedMessages => {
          if (missedMessages.length > 0) {
            setMessages(prev => [...prev, ...missedMessages]);
            toast.success('Reconnected. Fetched missed messages.');
          } else {
            toast.success('Reconnected.');
          }
        });
      }
    });

    newSocket.on('disconnect', () => {
      console.log('Socket disconnected');
      setIsConnected(false);
    });

    newSocket.on('connect_error', (error) => {
      console.error('Socket connection error:', error);
      setIsConnected(false);
    });

    newSocket.on('new-message', (message: Message) => {
      setMessages(prev => [...prev, message]);
      lastMessageTimeRef.current = message.created_at;
    });

    setSocket(newSocket);

    return () => newSocket.close();
  }, [conversationId]);

  const sendMessage = useCallback((content: string) => {
    if (socket && isConnected) {
      socket.emit('send-message', { conversationId, content });
    } else {
      toast.error('Cannot send message. Connection lost.');
    }
  }, [socket, isConnected, conversationId]);

  return { socket, messages, isConnected, sendMessage };
}

async function fetchMissedMessages(conversationId: string, since: string): Promise<Message[]> {
  const response = await fetch(`/api/v1/conversations/${conversationId}/messages?since=${since}`);
  return response.json();
}
```

### Typing Indicator UI Component

```typescript
// frontend/features/messages/components/TypingIndicator.tsx

interface TypingIndicatorProps {
  typingUser: { id: string; name: string } | null;
}

export function TypingIndicator({ typingUser }: TypingIndicatorProps) {
  const [dots, setDots] = useState('...');

  // Animate dots
  useEffect(() => {
    if (!typingUser) return;

    const interval = setInterval(() => {
      setDots(prev => {
        if (prev === '...') return '.  ';
        if (prev === '.  ') return ' . ';
        if (prev === ' . ') return '  .';
        return '...';
      });
    }, 500);

    return () => clearInterval(interval);
  }, [typingUser]);

  if (!typingUser) return null;

  return (
    <div className="flex items-center gap-2 px-4 py-2 text-sm text-gray-500 italic transition-opacity duration-200">
      <div className="flex space-x-1">
        <div className="w-2 h-2 bg-gray-400 rounded-full animate-bounce" style={{ animationDelay: '0ms' }} />
        <div className="w-2 h-2 bg-gray-400 rounded-full animate-bounce" style={{ animationDelay: '150ms' }} />
        <div className="w-2 h-2 bg-gray-400 rounded-full animate-bounce" style={{ animationDelay: '300ms' }} />
      </div>
      <span>{typingUser.name} is typing{dots}</span>
    </div>
  );
}
```

**Integration in Chat Window:**

```typescript
// frontend/features/messages/components/ChatWindow.tsx (updated)

import { useTypingIndicator } from '@/hooks/useTypingIndicator';
import { TypingIndicator } from './TypingIndicator';

export function ChatWindow({ conversationId }: { conversationId: string }) {
  const { socket, messages, isConnected, sendMessage } = useSocket(conversationId);
  const { typingUser, handleTyping, emitTypingStop } = useTypingIndicator(socket, conversationId);

  const handleSendMessage = (content: string) => {
    sendMessage(content);
    emitTypingStop(); // Stop typing indicator when message sent
  };

  return (
    <div className="flex flex-col h-full">
      {/* Connection Status */}
      <ConnectionStatus conversationId={conversationId} />

      {/* Messages */}
      <MessageList messages={messages} />

      {/* Typing Indicator */}
      <TypingIndicator typingUser={typingUser} />

      {/* Message Input */}
      <MessageInput
        onSendMessage={handleSendMessage}
        onTyping={handleTyping}
      />
    </div>
  );
}
```

### Performance Considerations

**Event Throttling:**
- Typing events are debounced (300ms start, 3s stop)
- Server-side timeout prevents stuck indicators (5s)
- Toast notifications don't interfere with conversation page

**Memory Management:**
- Typing state stored in-memory only (not database)
- Server-side typing map cleaned up on disconnect
- Frontend timers cleared on component unmount

**Network Efficiency:**
- Typing events: ~50 bytes each
- Expected frequency: 1-2 events per user per typing session
- Minimal bandwidth overhead compared to polling

### Testing Strategy

**Unit Tests:**
```typescript
// frontend/hooks/__tests__/useTypingIndicator.test.ts

describe('useTypingIndicator', () => {
  it('emits typing-start after 300ms of typing', async () => {
    const { result } = renderHook(() => useTypingIndicator(mockSocket, 'conv-123'));

    act(() => result.current.handleTyping());

    await waitFor(() => {
      expect(mockSocket.emit).toHaveBeenCalledWith('typing-start', { conversationId: 'conv-123' });
    }, { timeout: 500 });
  });

  it('emits typing-stop after 3 seconds of inactivity', async () => {
    const { result } = renderHook(() => useTypingIndicator(mockSocket, 'conv-123'));

    act(() => result.current.handleTyping());

    await waitFor(() => {
      expect(mockSocket.emit).toHaveBeenCalledWith('typing-stop', { conversationId: 'conv-123' });
    }, { timeout: 3500 });
  });

  it('shows typing indicator when user-typing event received', () => {
    const { result } = renderHook(() => useTypingIndicator(mockSocket, 'conv-123'));

    act(() => {
      mockSocket.emit('user-typing', { user_id: '456', user_name: 'Alice' });
    });

    expect(result.current.typingUser).toEqual({ id: '456', name: 'Alice' });
  });
});
```

**E2E Test:**
```typescript
// e2e/specs/messages/notifications.spec.ts

test('shows toast notification when message received on different page', async ({ browser }) => {
  const recruiterPage = await browser.newPage();
  const candidatePage = await browser.newPage();

  // Recruiter on dashboard (not messages page)
  await recruiterPage.goto('/dashboard');

  // Candidate sends message
  await candidatePage.goto('/messages/conv-123');
  await candidatePage.fill('[data-testid="message-input"]', 'Hello!');
  await candidatePage.click('[data-testid="send-button"]');

  // Verify toast appears on recruiter page
  await recruiterPage.waitForSelector('text=Candidate Name: Hello!', { timeout: 2000 });

  // Click toast to navigate
  await recruiterPage.click('text=View');

  // Verify navigated to conversation
  expect(recruiterPage.url()).toContain('/messages/conv-123');
});

test('typing indicator appears and disappears', async ({ browser }) => {
  const page1 = await browser.newPage();
  const page2 = await browser.newPage();

  await page1.goto('/messages/conv-123');
  await page2.goto('/messages/conv-123');

  // User 1 starts typing
  await page1.fill('[data-testid="message-input"]', 'H');

  // User 2 sees typing indicator
  await page2.waitForSelector('text=User 1 is typing', { timeout: 1000 });

  // User 1 stops typing
  await page1.fill('[data-testid="message-input"]', '');
  await page1.waitForTimeout(3000);

  // Typing indicator disappears
  await expect(page2.locator('text=User 1 is typing')).not.toBeVisible();
});
```

### Common Pitfalls to Avoid

1. ❌ **Don't show toast on active conversation page** → Check pathname before showing toast
2. ❌ **Don't forget to clear typing timers** → Clean up useEffect, emit typing-stop on unmount
3. ❌ **Don't spam typing events** → Use debounce (300ms) to limit emission frequency
4. ❌ **Don't persist typing events to database** → In-memory only for performance
5. ❌ **Don't show typing indicator for own typing** → Filter by user ID
6. ❌ **Don't forget server-side timeout** → Prevents stuck indicators if client disconnects
7. ❌ **Don't block UI with connection status** → Auto-hide "Connected" badge after 2s

### References

- [Source: Story 7.1] Socket.io infrastructure, useSocket hook
- [Source: Story 7.2] Bidirectional messaging, authorization
- [Source: Story 7.3] Conversation list context, user rooms pattern
- [Source: Sonner Library] Toast notification system
- [Source: Socket.io Documentation] Typing indicator patterns

### Dependencies

**Blocked By:**
- Story 7.1: Socket.io server and frontend hooks
- Story 7.2: Bidirectional messaging working
- Story 7.3: Conversation list context and global socket

**Blocks:**
- None (Story 7.4 is final story in Epic 7)

### Phase 1 Scope

✅ **Included in Phase 1:**
1. Toast notifications on new messages (via Sonner)
2. Typing indicator (typing-start, typing-stop, user-typing events)
3. Navigation badge with unread count
4. Connection status indicator (green/red)

❌ **Phase 2 (Future Work):**
- Push notifications for mobile devices
- Email notifications for offline users
- Read receipts (checkmarks showing message read)
- Message delivery status (sent, delivered, read)
- Notification preferences (mute conversations)

---

## Dev Agent Record

### Agent Model Used

_To be filled by Dev agent during implementation_

### Debug Log References

_To be filled by Dev agent during implementation_

### Completion Notes

_To be filled by Dev agent upon completion_

### File List

_To be filled by Dev agent with all files created/modified during implementation_
