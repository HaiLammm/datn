# Story 7.3: Danh sách cuộc trò chuyện

Status: ready-for-dev

## Epic
Epic 7: Trò chuyện Trực tuyến (Real-time Messaging with Socket.io)

## Story

As a **User** (both Recruiter and Candidate),
I want to **see a list of all my conversations**,
so that **I can easily manage and track my communications with real-time updates**.

## Acceptance Criteria

1. User must be able to access a page displaying list of all conversations
2. Each conversation item must display other participant's name/avatar, last message, and timestamp
3. Conversations with unread messages must be clearly marked (bold text + unread badge)
4. List must be sorted by latest message timestamp (newest first)
5. User can click on a conversation to open detailed chat interface
6. If no conversations exist, display "Bạn chưa có cuộc trò chuyện nào" empty state
7. **NEW:** Conversation list updates in real-time when new messages arrive (via Socket.io)
8. **NEW:** Unread count updates in real-time without page refresh

## Tasks / Subtasks

### Backend Tasks - REST API

- [ ] **Conversation List Endpoint** (AC: 1, 2, 3, 4)
  - [ ] Create or update `GET /api/v1/conversations` endpoint in `backend/app/modules/messages/router.py`
  - [ ] Query conversations where user is participant (recruiter_id OR candidate_id = current_user.id)
  - [ ] JOIN with users table to get other participant's info (name, avatar, role)
  - [ ] LEFT JOIN with messages table to get last message (ORDER BY created_at DESC LIMIT 1)
  - [ ] Calculate unread_count per conversation (COUNT WHERE is_read = FALSE AND sender_id != current_user.id)
  - [ ] Sort by conversation.updated_at DESC (most recent first)
  - [ ] Return ConversationListResponse array

- [ ] **Pydantic Schema for Response** (AC: 2, 3)
  - [ ] Create `ConversationListItemSchema` in `backend/app/modules/messages/schemas.py`:
    - `conversation_id: str`
    - `other_participant: UserBasicInfo` (id, name, avatar, role)
    - `last_message: MessagePreview` (content, timestamp, sender_id)
    - `unread_count: int`
    - `updated_at: datetime`

- [ ] **Database Query Optimization** (AC: 4)
  - [ ] Use LATERAL JOIN for last message (efficient)
  - [ ] Use subquery or window function for unread count
  - [ ] Verify indexes exist: `conversations.updated_at`, `messages.is_read`, `messages.conversation_id`
  - [ ] Test query performance with 100+ conversations (<100ms)

- [ ] **Mark Messages as Read Endpoint** (AC: 3)
  - [ ] Create `PATCH /api/v1/conversations/:id/mark-read` endpoint
  - [ ] Update all messages in conversation WHERE is_read = FALSE AND sender_id != current_user.id
  - [ ] SET is_read = TRUE
  - [ ] Return updated unread_count

### Backend Tasks - Socket.io Real-time Updates

- [ ] **Socket.io Event: conversation-updated** (AC: 7, 8)
  - [ ] Add new event handler in `socket-server/server.js`
  - [ ] When message is sent, emit `conversation-updated` event to both participants
  - [ ] Event payload: `{ conversation_id, last_message, unread_count, updated_at }`
  - [ ] Emit to user-specific rooms: `user:${recruiterId}` and `user:${candidateId}`

- [ ] **User Room Subscription** (AC: 7)
  - [ ] When user connects to Socket.io, automatically join their user room: `user:${userId}`
  - [ ] User room is persistent across all pages (not conversation-specific)
  - [ ] Used for global notifications (new message in any conversation)

- [ ] **Integration with send-message Event** (AC: 7, 8)
  - [ ] Update existing `send-message` event handler in `socket-server/handlers/message.js`
  - [ ] After broadcasting `new-message` to conversation room, also emit `conversation-updated` to user rooms
  - [ ] Calculate new unread count for each participant
  - [ ] Update conversation.updated_at timestamp in database

### Frontend Tasks - Conversation List Page

- [ ] **Conversations List Page** (AC: 1, 5, 6)
  - [ ] Create or update `frontend/app/messages/page.tsx`
  - [ ] Fetch conversations on load: `GET /api/v1/conversations`
  - [ ] Display list of ConversationListItem components
  - [ ] Show empty state if conversations array is empty
  - [ ] Add loading skeleton while fetching

- [ ] **ConversationListItem Component** (AC: 2, 3, 4)
  - [ ] Create `frontend/features/messages/components/ConversationListItem.tsx`
  - [ ] Display other participant's avatar (circular)
  - [ ] Display other participant's name (bold if unread)
  - [ ] Display last message preview (truncated to 60 chars, add "...")
  - [ ] Display relative timestamp ("2 min ago", "1 hour ago", "Yesterday")
  - [ ] Display unread count badge (blue circle with number) if unread_count > 0
  - [ ] Highlight background with subtle color if unread
  - [ ] onClick: Navigate to `/messages/:conversationId`

- [ ] **Empty State Component** (AC: 6)
  - [ ] Create `frontend/features/messages/components/EmptyConversations.tsx`
  - [ ] Display message icon or illustration
  - [ ] Display text: "Bạn chưa có cuộc trò chuyện nào"
  - [ ] Optional: Show CTA button "Start a conversation" (link to job search or applicants)

### Frontend Tasks - Socket.io Real-time Updates

- [ ] **Global Socket Connection** (AC: 7, 8)
  - [ ] Create `frontend/hooks/useGlobalSocket.ts` (different from `useSocket` for specific conversation)
  - [ ] Initialize Socket.io connection at app level (layout or context provider)
  - [ ] Join user room automatically: `socket.emit('join-user-room')`
  - [ ] Listen for `conversation-updated` events globally

- [ ] **Real-time Conversation List Updates** (AC: 7, 8)
  - [ ] In `/messages` page, subscribe to `conversation-updated` events
  - [ ] When event received:
    - Find conversation in local state by conversation_id
    - Update last_message, unread_count, updated_at
    - Re-sort list (move updated conversation to top)
    - Update UI without page refresh
  - [ ] Use optimistic UI pattern (show update immediately)

- [ ] **Mark as Read on Conversation Open** (AC: 3, 8)
  - [ ] When user clicks conversation and navigates to `/messages/:conversationId`
  - [ ] Call `PATCH /api/v1/conversations/:id/mark-read`
  - [ ] Update local conversation list state (set unread_count = 0)
  - [ ] Update navigation badge count (from Story 7.4)

- [ ] **State Management** (AC: 7, 8)
  - [ ] Use React Context or Zustand for global conversation list state
  - [ ] State includes: conversations array, loading state, error state
  - [ ] Provide actions: `updateConversation`, `addConversation`, `markAsRead`
  - [ ] Share state between conversation list page and navigation badge

### Testing Tasks

- [ ] **Backend API Tests** (AC: 1, 2, 3, 4)
  - [ ] Test `GET /api/v1/conversations` returns user's conversations
  - [ ] Test conversations sorted by updated_at DESC
  - [ ] Test unread_count calculated correctly
  - [ ] Test other participant info included correctly
  - [ ] Test performance with 100+ conversations (<100ms)

- [ ] **Socket.io Real-time Tests** (AC: 7, 8)
  - [ ] Test `conversation-updated` event emitted when message sent
  - [ ] Test event received by both conversation participants
  - [ ] Test unread count updates in real-time
  - [ ] Test conversation list re-orders automatically

- [ ] **Frontend Component Tests** (AC: 2, 3, 6)
  - [ ] Test ConversationListItem renders correctly
  - [ ] Test unread badge displays when unread_count > 0
  - [ ] Test empty state displays when no conversations
  - [ ] Test clicking conversation navigates to chat

- [ ] **E2E Test** (AC: All)
  - [ ] Test full flow:
    1. User A and User B have conversation
    2. User A opens conversation list page
    3. User B sends message
    4. User A's conversation list updates in real-time (no refresh)
    5. Unread badge appears
    6. User A clicks conversation → badge disappears
  - [ ] Verify list sorts correctly after new message

## Dev Notes

### Architecture: Socket.io Real-time Updates for Conversation List

**Key Innovation:** Story 7.3 extends Socket.io beyond individual conversations to enable **global conversation list updates**. When a new message arrives in any conversation, the list updates in real-time without user refreshing the page.

### Socket.io User Rooms Pattern

**New Pattern: User-specific Rooms**

```javascript
// socket-server/server.js

io.on('connection', (socket) => {
  const userId = socket.userId; // From JWT auth

  // Join user-specific room (global, not conversation-specific)
  socket.join(`user:${userId}`);
  console.log(`User ${userId} joined user room`);

  // Existing conversation room joins still work
  socket.on('join-conversation', (conversationId) => {
    socket.join(`conversation:${conversationId}`);
  });
});
```

**Why User Rooms?**
- Allows sending events to a specific user across ALL their conversations
- Used for global notifications (conversation list updates, notification badges)
- Persists as long as user is connected (not tied to specific page)

### conversation-updated Event Flow

**Server-side Implementation:**

```javascript
// socket-server/handlers/message.js

socket.on('send-message', async (data) => {
  const { conversationId, content } = data;

  // 1. Save message to database via FastAPI
  const message = await saveMessageToDB(conversationId, socket.userId, content);

  // 2. Broadcast message to conversation room (existing)
  io.to(`conversation:${conversationId}`).emit('new-message', message);

  // 3. NEW: Fetch conversation details
  const conversation = await getConversationDetails(conversationId);

  // 4. NEW: Emit conversation-updated to BOTH participants' user rooms
  const participants = [conversation.recruiter_id, conversation.candidate_id];

  participants.forEach(participantId => {
    // Calculate unread count specific to this participant
    const unreadCount = await getUnreadCount(conversationId, participantId);

    io.to(`user:${participantId}`).emit('conversation-updated', {
      conversation_id: conversationId,
      last_message: {
        content: message.content,
        timestamp: message.created_at,
        sender_id: socket.userId
      },
      unread_count: unreadCount,
      updated_at: new Date().toISOString()
    });
  });
});
```

**Frontend Implementation:**

```typescript
// frontend/hooks/useGlobalSocket.ts

export function useGlobalSocket() {
  const [socket, setSocket] = useState<Socket | null>(null);

  useEffect(() => {
    const token = getAuthToken();
    const newSocket = io(process.env.NEXT_PUBLIC_SOCKET_URL!, {
      auth: { token }
    });

    newSocket.on('connect', () => {
      console.log('Global socket connected');
      // User room join happens automatically on server side
    });

    setSocket(newSocket);

    return () => newSocket.close();
  }, []);

  return socket;
}

// frontend/app/messages/page.tsx

export default function MessagesPage() {
  const [conversations, setConversations] = useState<Conversation[]>([]);
  const socket = useGlobalSocket();

  // Initial load via REST API
  useEffect(() => {
    async function loadConversations() {
      const response = await fetch('/api/v1/conversations');
      const data = await response.json();
      setConversations(data);
    }
    loadConversations();
  }, []);

  // Real-time updates via Socket.io
  useEffect(() => {
    if (!socket) return;

    socket.on('conversation-updated', (data) => {
      setConversations(prev => {
        // Find and update conversation
        const updated = prev.map(conv =>
          conv.conversation_id === data.conversation_id
            ? { ...conv, ...data }
            : conv
        );

        // Re-sort by updated_at (newest first)
        return updated.sort((a, b) =>
          new Date(b.updated_at).getTime() - new Date(a.updated_at).getTime()
        );
      });
    });

    return () => {
      socket.off('conversation-updated');
    };
  }, [socket]);

  return (
    <div>
      {conversations.length === 0 ? (
        <EmptyConversations />
      ) : (
        conversations.map(conv => (
          <ConversationListItem key={conv.conversation_id} conversation={conv} />
        ))
      )}
    </div>
  );
}
```

### Database Query Optimization

**Complex SQL Query for Conversation List:**

```sql
-- Optimized query with LATERAL JOIN
SELECT
  c.id,
  c.created_at,
  c.updated_at,
  -- Other participant info
  u.id as other_user_id,
  u.name as other_user_name,
  u.avatar as other_user_avatar,
  u.role as other_user_role,
  -- Last message
  last_msg.content as last_message_content,
  last_msg.created_at as last_message_time,
  last_msg.sender_id as last_message_sender_id,
  -- Unread count
  (
    SELECT COUNT(*)
    FROM messages m
    WHERE m.conversation_id = c.id
      AND m.is_read = FALSE
      AND m.sender_id != :current_user_id
  ) as unread_count
FROM conversations c
-- Join with other participant (not current user)
JOIN users u ON (
  CASE
    WHEN c.recruiter_id = :current_user_id THEN u.id = c.candidate_id
    ELSE u.id = c.recruiter_id
  END
)
-- Get last message using LATERAL JOIN (efficient)
LEFT JOIN LATERAL (
  SELECT content, created_at, sender_id
  FROM messages
  WHERE conversation_id = c.id
  ORDER BY created_at DESC
  LIMIT 1
) last_msg ON true
WHERE
  c.recruiter_id = :current_user_id OR c.candidate_id = :current_user_id
ORDER BY
  c.updated_at DESC;
```

**Performance Notes:**
- LATERAL JOIN is more efficient than subquery for last message
- Subquery for unread_count is fast due to index on `messages.is_read`
- Index on `conversations.updated_at` ensures fast sorting
- Expected query time: <50ms for 100 conversations

### State Management Pattern

**Option 1: React Context (Recommended for simplicity)**

```typescript
// frontend/contexts/ConversationsContext.tsx

interface ConversationsContextType {
  conversations: Conversation[];
  updateConversation: (conversationId: string, updates: Partial<Conversation>) => void;
  markAsRead: (conversationId: string) => void;
  totalUnreadCount: number;
}

export function ConversationsProvider({ children }: { children: React.ReactNode }) {
  const [conversations, setConversations] = useState<Conversation[]>([]);
  const socket = useGlobalSocket();

  // Socket.io real-time updates
  useEffect(() => {
    if (!socket) return;

    socket.on('conversation-updated', (data) => {
      updateConversation(data.conversation_id, data);
    });
  }, [socket]);

  const updateConversation = (conversationId: string, updates: Partial<Conversation>) => {
    setConversations(prev => {
      const updated = prev.map(conv =>
        conv.conversation_id === conversationId ? { ...conv, ...updates } : conv
      );
      return updated.sort((a, b) =>
        new Date(b.updated_at).getTime() - new Date(a.updated_at).getTime()
      );
    });
  };

  const markAsRead = async (conversationId: string) => {
    await fetch(`/api/v1/conversations/${conversationId}/mark-read`, { method: 'PATCH' });
    updateConversation(conversationId, { unread_count: 0 });
  };

  const totalUnreadCount = conversations.reduce((sum, conv) => sum + conv.unread_count, 0);

  return (
    <ConversationsContext.Provider value={{ conversations, updateConversation, markAsRead, totalUnreadCount }}>
      {children}
    </ConversationsContext.Provider>
  );
}
```

### UI/UX Patterns

**Unread Indicator Styling:**

```tsx
// ConversationListItem.tsx

<div
  className={`
    flex items-center p-4 rounded-lg cursor-pointer
    hover:bg-gray-100 transition-colors
    ${conversation.unread_count > 0 ? 'bg-blue-50' : ''}
  `}
  onClick={() => router.push(`/messages/${conversation.conversation_id}`)}
>
  {/* Avatar */}
  <Avatar src={conversation.other_participant.avatar} />

  <div className="flex-1 ml-4">
    {/* Name - bold if unread */}
    <div className={`text-sm ${conversation.unread_count > 0 ? 'font-bold' : 'font-normal'}`}>
      {conversation.other_participant.name}
    </div>

    {/* Last message preview - gray if read, black if unread */}
    <div className={`text-xs truncate ${conversation.unread_count > 0 ? 'text-gray-900' : 'text-gray-500'}`}>
      {conversation.last_message.content}
    </div>
  </div>

  <div className="flex flex-col items-end">
    {/* Timestamp */}
    <div className="text-xs text-gray-400">
      {formatRelativeTime(conversation.last_message.timestamp)}
    </div>

    {/* Unread badge */}
    {conversation.unread_count > 0 && (
      <div className="mt-1 bg-blue-500 text-white text-xs rounded-full w-5 h-5 flex items-center justify-center">
        {conversation.unread_count}
      </div>
    )}
  </div>
</div>
```

### Testing Strategy

**Real-time Update Test:**

```typescript
// e2e/specs/messages/conversation-list-realtime.spec.ts

test('conversation list updates in real-time when message received', async ({ browser }) => {
  // Open two browser contexts
  const recruiterPage = await browser.newPage();
  const candidatePage = await browser.newPage();

  // Recruiter opens conversation list
  await recruiterPage.goto('/messages');

  // Candidate sends message
  await candidatePage.goto('/messages/conv-123');
  await candidatePage.fill('[data-testid="message-input"]', 'New message!');
  await candidatePage.click('[data-testid="send-button"]');

  // Verify recruiter's conversation list updates WITHOUT refresh
  await recruiterPage.waitForSelector('text=New message!', { timeout: 2000 });

  // Verify unread badge appears
  await recruiterPage.waitForSelector('[data-testid="unread-badge"]');

  // Verify conversation moved to top of list
  const firstConversation = recruiterPage.locator('[data-testid="conversation-item"]').first();
  await expect(firstConversation).toContainText('New message!');
});
```

### Performance Considerations

**Optimizations:**
1. **Debounce rapid updates:** If multiple messages arrive quickly, batch updates
2. **Lazy loading:** Load conversations in batches (20 at a time) for users with many conversations
3. **Virtual scrolling:** Use react-window for lists with 100+ conversations
4. **Cache conversation list:** Store in React Context to avoid refetching on navigation

**Memory Management:**
- Limit conversation list to most recent 100 conversations
- Older conversations load on scroll or search
- Socket connection is shared across entire app (single instance)

### Common Pitfalls to Avoid

1. ❌ **Don't create new Socket connection per page** → Use single global Socket connection
2. ❌ **Don't forget to re-sort list after update** → Always sort by updated_at DESC
3. ❌ **Don't show unread count for messages user sent** → Filter by sender_id != current_user
4. ❌ **Don't forget to unsubscribe from events** → Clean up Socket listeners in useEffect return
5. ❌ **Don't block UI while fetching conversations** → Show loading skeleton
6. ❌ **Don't forget empty state** → Handle zero conversations gracefully

### References

- [Source: Story 7.1] Socket.io infrastructure, database schema
- [Source: Story 7.2] Bidirectional messaging, authorization patterns
- [Source: PostgreSQL LATERAL JOIN] Efficient last message query
- [Source: React Context API] Global state management

### Dependencies

**Blocked By:**
- Story 7.1: Socket.io server must be running
- Story 7.2: Bidirectional messaging must work

**Blocks:**
- Story 7.4: Notification badge needs conversation list state

### Phase 1 Scope

✅ **Included in Phase 1:**
1. Conversation list with unread indicators
2. Real-time updates via Socket.io
3. Sort by most recent
4. Mark as read functionality

❌ **Phase 2 (Future Work):**
- Search conversations
- Filter conversations (read/unread, by participant)
- Archive conversations
- Conversation preview longer than 60 chars (click to expand)

---

## Dev Agent Record

### Agent Model Used

_To be filled by Dev agent during implementation_

### Debug Log References

_To be filled by Dev agent during implementation_

### Completion Notes

_To be filled by Dev agent upon completion_

### File List

_To be filled by Dev agent with all files created/modified during implementation_
