# Story 3.2.1: Update Parsed Requirements API

## Status
Done

## Story
**As a** Talent Seeker (Recruiter),
**I want** to edit the AI-extracted requirements from my Job Description,
**So that** I can correct any parsing errors and fine-tune the matching criteria.

## Acceptance Criteria

1. Create PATCH endpoint `/api/v1/jobs/jd/{jd_id}/parsed-requirements` to update parsed requirements
2. Endpoint accepts partial updates for: `required_skills`, `nice_to_have_skills`, `min_experience_years`
3. Endpoint requires authentication and ownership check (user must own the JD)
4. Endpoint returns 404 if JD not found or user doesn't own it
5. Endpoint returns 400 if JD parse_status is not 'completed' (can only edit after successful parsing)
6. After update, parse_status remains 'completed' (not reset to pending)
7. Response returns updated `JDParseStatusResponse` with new parsed_requirements
8. Unit tests for service layer and integration tests for router

## Tasks / Subtasks

- [x] **Task 1: Create Update Schema (AC: 2)**
    - [x] Add `ParsedRequirementsUpdate` schema to `backend/app/modules/jobs/schemas.py`
    - [x] Fields (all optional):
        - [x] `required_skills: Optional[List[str]]`
        - [x] `nice_to_have_skills: Optional[List[str]]`
        - [x] `min_experience_years: Optional[int]` (ge=0)
    - [x] Validation: skills lists must contain non-empty strings if provided

- [x] **Task 2: Create Service Function (AC: 1, 6)**
    - [x] Add `update_parsed_requirements()` function to `backend/app/modules/jobs/services.py`
    - [x] Function signature: `async def update_parsed_requirements(db: AsyncSession, jd_id: UUID, user_id: int, data: ParsedRequirementsUpdate) -> Optional[JobDescription]`
    - [x] Merge update data with existing `parsed_requirements` JSONB
    - [x] Only update fields that are provided (not None)
    - [x] Keep `parse_status` as 'completed'
    - [x] Return updated JD or None if not found/not owned

- [x] **Task 3: Create PATCH Endpoint (AC: 1, 3, 4, 5, 7)**
    - [x] Add PATCH `/jd/{jd_id}/parsed-requirements` endpoint to `backend/app/modules/jobs/router.py`
    - [x] Use `get_current_user` dependency for authentication
    - [x] Ownership check: call `get_job_description(db, jd_id, user_id)`
    - [x] Status check: return 400 if `parse_status != 'completed'`
    - [x] Call `update_parsed_requirements()` service function
    - [x] Return `JDParseStatusResponse` with updated data

- [x] **Task 4: Write Unit Tests (AC: 8)**
    - [x] Add tests to `backend/tests/modules/jobs/test_job_service.py`:
        - [x] `test_update_parsed_requirements_success`
        - [x] `test_update_parsed_requirements_partial_update`
        - [x] `test_update_parsed_requirements_jd_not_found`
        - [x] `test_update_parsed_requirements_wrong_owner`
    - [x] Add tests to `backend/tests/modules/jobs/test_job_router.py`:
        - [x] `test_patch_parsed_requirements_success`
        - [x] `test_patch_parsed_requirements_unauthenticated` (was unauthorized)
        - [x] `test_patch_parsed_requirements_not_found`
        - [x] `test_patch_parsed_requirements_not_completed`
        - [x] `test_patch_parsed_requirements_partial_update`
        - [x] `test_patch_parsed_requirements_failed_status` (additional)
        - [x] `test_patch_parsed_requirements_empty_skills_list` (additional)
        - [x] `test_patch_parsed_requirements_invalid_min_experience` (additional)

## Dev Notes

### Previous Story Insights (Story 3.2)

From Story 3.2 implementation:
- `parsed_requirements` is stored as JSONB field in `JobDescription` model
- `ParsedJDRequirements` schema already exists with all required fields
- `JDParseStatusResponse` schema is used for parse-status endpoint responses
- Existing ownership check pattern: `get_job_description(db, jd_id, user_id)`

**[Source: docs/stories/3.2.story.md, backend/app/modules/jobs/schemas.py]**

### Existing Schema: ParsedJDRequirements

```python
class ParsedJDRequirements(BaseModel):
    required_skills: List[str] = Field(default_factory=list)
    nice_to_have_skills: List[str] = Field(default_factory=list)
    min_experience_years: Optional[int] = Field(default=None, ge=0)
    job_title_normalized: Optional[str] = Field(default=None)
    key_responsibilities: List[str] = Field(default_factory=list)
    skill_categories: Optional[Dict[str, List[str]]] = Field(default=None)
```

**[Source: backend/app/modules/jobs/schemas.py:24-56]**

### API Endpoint Design

```yaml
PATCH /api/v1/jobs/jd/{jd_id}/parsed-requirements
Authorization: Bearer <token>
Content-Type: application/json

Request Body:
{
    "required_skills": ["python", "fastapi", "postgresql"],  # optional
    "nice_to_have_skills": ["docker", "kubernetes"],         # optional
    "min_experience_years": 3                                 # optional
}

Response: 200 OK
{
    "jd_id": "uuid",
    "parse_status": "completed",
    "parsed_requirements": {
        "required_skills": ["python", "fastapi", "postgresql"],
        "nice_to_have_skills": ["docker", "kubernetes"],
        "min_experience_years": 3,
        "job_title_normalized": "Senior Python Developer",  # preserved
        "key_responsibilities": [...]                        # preserved
    },
    "parse_error": null
}

Error Responses:
- 400 Bad Request: JD parse_status is not 'completed'
- 401 Unauthorized: Missing or invalid auth token
- 404 Not Found: JD not found or user doesn't own it
- 422 Validation Error: Invalid request body
```

### Service Implementation Pattern

```python
async def update_parsed_requirements(
    db: AsyncSession,
    jd_id: UUID,
    user_id: int,
    data: ParsedRequirementsUpdate
) -> Optional[JobDescription]:
    """
    Update parsed requirements for a job description.
    
    Only updates fields that are provided (not None).
    Preserves existing fields like job_title_normalized and key_responsibilities.
    """
    # Get JD with ownership check
    jd = await get_job_description(db, jd_id, user_id)
    if jd is None:
        return None
    
    # Merge with existing parsed_requirements
    current = jd.parsed_requirements or {}
    update_dict = data.model_dump(exclude_none=True)
    
    merged = {**current, **update_dict}
    
    # Update in database
    stmt = (
        update(JobDescription)
        .where(JobDescription.id == jd_id)
        .values(parsed_requirements=merged)
    )
    await db.execute(stmt)
    await db.commit()
    await db.refresh(jd)
    
    return jd
```

**[Source: backend/app/modules/jobs/services.py patterns]**

### File Locations

**Files to Modify:**
```
backend/app/modules/jobs/
├── schemas.py              # Add ParsedRequirementsUpdate
├── services.py             # Add update_parsed_requirements()
└── router.py               # Add PATCH endpoint

backend/tests/modules/jobs/
├── test_job_service.py     # Add update tests
└── test_job_router.py      # Add PATCH endpoint tests
```

**[Source: docs/architecture/source-tree.md]**

### Technical Constraints

1. **Partial Updates:**
   - Only update fields that are explicitly provided
   - Use `exclude_none=True` when converting Pydantic model to dict
   - Preserve fields not included in update (e.g., `job_title_normalized`, `key_responsibilities`)

2. **Validation:**
   - Skills must be non-empty strings if provided
   - `min_experience_years` must be >= 0
   - Empty list `[]` is valid (clears all skills)

3. **Status Preservation:**
   - Do NOT reset `parse_status` to 'pending' after edit
   - User edits should be treated as final/authoritative
   - If user wants AI to re-parse, they can use `/reparse` endpoint

4. **JSONB Merge Strategy:**
   - Use Python dict merge: `{**existing, **updates}`
   - This overwrites existing keys with new values
   - Keys not in update are preserved

**[Source: docs/architecture/coding-standards.md]**

### Dependencies

- **Story 3.2.1 depends on:**
  - Story 3.1 (JD Module Foundation) - **DONE**
  - Story 3.2 (JD Parsing) - **DONE**

- **Stories that depend on 3.2.1:**
  - Story 3.5 (JD Upload Frontend) - AC7 requires this endpoint

## Testing

### Backend Tests

- **Location:** `backend/tests/modules/jobs/`
- **Framework:** `pytest` with async support (`pytest-asyncio`)
- **Run command:** `pytest backend/tests/modules/jobs/ -v`

### Test Patterns

```python
# test_job_service.py
@pytest.mark.asyncio
async def test_update_parsed_requirements_success(db_session, test_user, test_jd_completed):
    """Test successful update of parsed requirements."""
    update_data = ParsedRequirementsUpdate(
        required_skills=["python", "fastapi", "docker"],
        min_experience_years=5
    )
    
    result = await update_parsed_requirements(
        db_session, test_jd_completed.id, test_user.id, update_data
    )
    
    assert result is not None
    assert result.parsed_requirements["required_skills"] == ["python", "fastapi", "docker"]
    assert result.parsed_requirements["min_experience_years"] == 5
    # Preserved from original
    assert result.parsed_requirements["job_title_normalized"] == test_jd_completed.parsed_requirements["job_title_normalized"]


@pytest.mark.asyncio
async def test_update_parsed_requirements_partial_update(db_session, test_user, test_jd_completed):
    """Test partial update preserves unmodified fields."""
    original_nice_to_have = test_jd_completed.parsed_requirements["nice_to_have_skills"]
    
    update_data = ParsedRequirementsUpdate(
        required_skills=["react", "typescript"]
        # nice_to_have_skills not provided
    )
    
    result = await update_parsed_requirements(
        db_session, test_jd_completed.id, test_user.id, update_data
    )
    
    assert result.parsed_requirements["required_skills"] == ["react", "typescript"]
    assert result.parsed_requirements["nice_to_have_skills"] == original_nice_to_have


# test_job_router.py
@pytest.mark.asyncio
async def test_patch_parsed_requirements_success(
    async_client: AsyncClient,
    authenticated_user_cookies: dict,
    created_jd_completed: JobDescription
):
    response = await async_client.patch(
        f"/api/v1/jobs/jd/{created_jd_completed.id}/parsed-requirements",
        json={"required_skills": ["python", "django"]},
        cookies=authenticated_user_cookies
    )
    assert response.status_code == 200
    data = response.json()
    assert data["parse_status"] == "completed"
    assert data["parsed_requirements"]["required_skills"] == ["python", "django"]


@pytest.mark.asyncio
async def test_patch_parsed_requirements_not_completed(
    async_client: AsyncClient,
    authenticated_user_cookies: dict,
    created_jd_pending: JobDescription  # JD with parse_status='pending'
):
    response = await async_client.patch(
        f"/api/v1/jobs/jd/{created_jd_pending.id}/parsed-requirements",
        json={"required_skills": ["python"]},
        cookies=authenticated_user_cookies
    )
    assert response.status_code == 400
    assert "not completed" in response.json()["detail"].lower()
```

**[Source: docs/architecture/testing-strategy.md]**

### Test Fixtures Needed

```python
@pytest.fixture
async def test_jd_completed(db_session, test_user):
    """Create a JD with parse_status='completed' and parsed_requirements."""
    jd = JobDescription(
        user_id=test_user.id,
        title="Test JD",
        description="Test description",
        parse_status="completed",
        parsed_requirements={
            "required_skills": ["python", "fastapi"],
            "nice_to_have_skills": ["docker"],
            "min_experience_years": 3,
            "job_title_normalized": "Python Developer",
            "key_responsibilities": ["Write code"]
        }
    )
    db_session.add(jd)
    await db_session.commit()
    await db_session.refresh(jd)
    return jd
```

## Change Log

| Date | Version | Description | Author |
| :--- | :--- | :--- | :--- |
| 2025-12-18 | 1.0 | Initial draft - PATCH endpoint for updating parsed requirements | Sarah (PO) |
| 2025-12-18 | 1.1 | Implementation complete - all tasks done | James (Dev) |

---

## Dev Agent Record

### Agent Model Used
Claude Sonnet 4 (via OpenCode)

### File List

| File | Action | Description |
| :--- | :--- | :--- |
| `backend/app/modules/jobs/schemas.py` | Modified | Added `ParsedRequirementsUpdate` schema with validation |
| `backend/app/modules/jobs/services.py` | Modified | Added `update_parsed_requirements()` function |
| `backend/app/modules/jobs/router.py` | Modified | Added PATCH `/jd/{jd_id}/parsed-requirements` endpoint |
| `backend/tests/modules/jobs/test_job_service.py` | Modified | Added 4 tests for service layer |
| `backend/tests/modules/jobs/test_job_router.py` | Modified | Added 8 tests for PATCH endpoint |

### Completion Notes

- All 4 tasks completed successfully
- Service tests: 4 passed (TestUpdateParsedRequirements class)
- Router tests: 8 passed (TestPatchParsedRequirementsEndpoint class)
- Full regression: 433 passed, 3 skipped, 0 failures
- Added extra tests beyond story requirements: `test_patch_parsed_requirements_failed_status`, `test_patch_parsed_requirements_empty_skills_list`, `test_patch_parsed_requirements_invalid_min_experience`

### Debug Log References
N/A - No issues encountered during implementation

---

## QA Results

### Review Date: 2025-12-18

### Reviewed By: Quinn (Test Architect)

### Risk Assessment

| Risk Factor | Value | Escalation Trigger |
|:------------|:------|:-------------------|
| Auth/Security files touched | No | - |
| Tests added | Yes (12 tests) | - |
| Diff size | ~300 lines | No (< 500) |
| Previous gate status | N/A (first review) | - |
| Acceptance criteria count | 8 | Yes (> 5) |

**Review Depth:** Standard with enhanced AC traceability due to high AC count.

### Code Quality Assessment

**Overall: Excellent**

The implementation demonstrates solid engineering practices:

1. **Schema Design** (`schemas.py:59-91`): 
   - `ParsedRequirementsUpdate` properly uses Optional fields for partial updates
   - Field validator correctly handles skill list sanitization (strips whitespace, removes empties)
   - Appropriate `ge=0` constraint on `min_experience_years`

2. **Service Layer** (`services.py:187-230`):
   - Clean separation of concerns with `update_parsed_requirements()` function
   - Proper JSONB merge strategy using `{**current, **update_dict}` preserves existing fields
   - Uses `exclude_none=True` correctly for partial updates
   - Follows existing patterns for ownership checks

3. **Router Layer** (`router.py:152-207`):
   - Correct HTTP method (PATCH for partial updates)
   - Proper error handling with appropriate status codes (400, 404)
   - Clear docstrings explaining the endpoint behavior
   - Status check before allowing updates (parse_status == 'completed')

### Requirements Traceability

| AC# | Requirement | Test(s) | GWT Pattern |
|:----|:-----------|:--------|:------------|
| 1 | PATCH endpoint creation | `test_patch_parsed_requirements_success` | **Given** a completed JD, **When** I PATCH with new skills, **Then** I receive updated data |
| 2 | Partial updates for fields | `test_patch_parsed_requirements_partial_update` | **Given** existing requirements, **When** I update only `required_skills`, **Then** `nice_to_have_skills` is preserved |
| 3 | Auth + ownership check | `test_patch_parsed_requirements_unauthenticated` | **Given** no auth token, **When** I PATCH, **Then** I receive 401/403 |
| 4 | 404 on not found/not owned | `test_patch_parsed_requirements_not_found` | **Given** invalid JD ID, **When** I PATCH, **Then** I receive 404 |
| 5 | 400 if not completed | `test_patch_..._not_completed`, `test_patch_..._failed_status` | **Given** JD with pending/failed status, **When** I PATCH, **Then** I receive 400 |
| 6 | Status remains 'completed' | `test_patch_parsed_requirements_success` (assertion) | **Given** completed JD, **When** I update, **Then** `parse_status` remains 'completed' |
| 7 | Returns JDParseStatusResponse | All success tests | **Given** valid update, **When** I PATCH, **Then** response includes `jd_id`, `parse_status`, `parsed_requirements` |
| 8 | Unit + integration tests | 4 service + 8 router tests | **Given** story requirements, **When** reviewing tests, **Then** coverage is complete |

**AC Coverage: 8/8 (100%)**

### Test Architecture Assessment

**Test Quality: Strong**

| Aspect | Assessment | Notes |
|:-------|:-----------|:------|
| Test levels | ✅ Appropriate | Unit tests for service, integration tests for router |
| Coverage | ✅ Complete | All ACs covered, plus extra edge cases |
| Test isolation | ✅ Good | Proper mocking of dependencies |
| Error scenarios | ✅ Comprehensive | 404, 400, 401/403, 422 all tested |
| Edge cases | ✅ Extra coverage | Empty skills list, invalid experience, failed status |

**Tests Added Beyond Requirements:**
- `test_patch_parsed_requirements_failed_status` - validates 400 for 'failed' status
- `test_patch_parsed_requirements_empty_skills_list` - validates clearing skills
- `test_patch_parsed_requirements_invalid_min_experience` - validates 422 for negative values

### Compliance Check

- Coding Standards: ✅ Follows snake_case, proper module structure
- Project Structure: ✅ Changes in correct module locations (jobs/)
- Testing Strategy: ✅ Unit + integration tests with proper mocking
- All ACs Met: ✅ 8/8 acceptance criteria validated

### Improvements Checklist

- [x] Schema validation for skills lists (implemented via field_validator)
- [x] Partial update logic with field preservation (implemented correctly)
- [x] Appropriate HTTP status codes (400, 404 implemented)
- [x] Tests exceed minimum requirements (12 tests vs 8 required)
- [ ] Consider adding rate limiting for this endpoint (future enhancement)
- [ ] Consider logging the specific fields that were updated (observability enhancement)

### Security Review

**Status: PASS**

- ✅ Authentication required via `get_current_user` dependency
- ✅ Ownership check prevents unauthorized access to other users' JDs
- ✅ Input validation on skill lists and experience years
- ✅ No SQL injection risk (using SQLAlchemy ORM)
- ✅ 404 returned for both "not found" and "not owned" (prevents ID enumeration)

### Performance Considerations

**Status: PASS**

- ✅ Single database query for ownership check + update
- ✅ JSONB merge is efficient (Python dict operations)
- ✅ No N+1 query patterns
- ⚠️ Minor: Could use a single atomic update instead of get + update, but current approach is acceptable for data integrity

### Files Modified During Review

None - no refactoring performed. Implementation is clean.

### Gate Status

Gate: **PASS** → `docs/qa/gates/3.2.1-update-parsed-requirements-api.yml`

### Recommended Status

**✅ Ready for Done**

All acceptance criteria are met, test coverage is comprehensive (12 tests covering all 8 ACs plus edge cases), code quality is excellent, and no security or performance concerns were identified.
