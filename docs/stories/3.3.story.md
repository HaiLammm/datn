# Story 3.3: Candidate Ranking Engine

## Status
Done

## Story
**As a** Talent Seeker,
**I want** candidates ranked by relevance to my JD,
**So that** I can quickly find the best matches.

## Acceptance Criteria

1. Implement `CandidateRanker` class in `backend/app/modules/jobs/candidate_ranker.py`
2. Calculate match score (0-100) based on:
   - Skill overlap (weighted by importance: required vs nice-to-have)
   - Experience years match
   - Role/title relevance (optional bonus)
3. Return ranked list with match_score
4. Include breakdown: matched_skills, missing_skills, extra_skills
5. API endpoint: GET `/api/v1/jobs/jd/{jd_id}/candidates`
6. Support pagination (limit, offset)
7. Support filtering (min_score)
8. Unit tests for CandidateRanker class
9. Integration tests for candidates endpoint

## Tasks / Subtasks

- [x] **Task 1: Create CandidateRanker Class (AC: 1, 2, 3, 4)**
    - [x] Create file `backend/app/modules/jobs/candidate_ranker.py`
    - [x] Define `CandidateRanker` class
    - [x] Implement `rank_candidates(jd_id, db, limit, offset, min_score) -> RankedCandidateList`
    - [x] Implement `_calculate_match(jd_requirements, cv_analysis) -> RankedCandidate`
    - [x] Implement `_calculate_skill_score(required_skills, nice_to_have, cv_skills) -> SkillMatchDetails`
    - [x] Implement `_calculate_experience_score(required_years, cv_years) -> float`
    - [x] Store matched_skills, missing_skills, extra_skills in breakdown

- [x] **Task 2: Create Pydantic Schemas for Ranking (AC: 3, 4)**
    - [x] Update `backend/app/modules/jobs/schemas.py`
    - [x] Create `MatchBreakdownResponse` schema (matched_skills, missing_skills, extra_skills)
    - [x] Create `RankedCandidateResponse` schema (cv_id, match_score, breakdown, cv_summary)
    - [x] Create `RankedCandidateListResponse` schema for paginated response

- [x] **Task 3: Create API Endpoint (AC: 5, 6, 7)**
    - [x] Add GET `/api/v1/jobs/jd/{jd_id}/candidates` endpoint in router.py
    - [x] Accept query params: limit (default 20), offset (default 0), min_score (default 0)
    - [x] Require authentication
    - [x] Check JD ownership
    - [x] Return 404 if JD not found, 409 if parse not complete
    - [x] Return ranked candidates with pagination

- [x] **Task 4: Write Unit Tests (AC: 8)**
    - [x] Create `backend/tests/modules/jobs/test_candidate_ranker.py` (31 tests)
    - [x] `TestMatchBreakdown` - Test dataclass conversion
    - [x] `TestRankedCandidate` - Test dataclass conversion
    - [x] `TestCalculateSkillScore` - 7 tests for skill matching
    - [x] `TestCalculateExperienceScore` - 7 tests for experience scoring
    - [x] `TestExtractExperienceYears` - 5 tests for extracting years
    - [x] `TestCalculateMatch` - 3 tests for full match calculation
    - [x] `TestRankCandidates` - 6 tests for ranking with mocked DB

- [x] **Task 5: Write Integration Tests (AC: 9)**
    - [x] Update `backend/tests/modules/jobs/test_job_router.py` (11 new tests)
    - [x] `test_get_candidates_success` - Returns ranked candidates
    - [x] `test_get_candidates_with_pagination` - Verify limit/offset works
    - [x] `test_get_candidates_with_min_score_filter` - Verify min_score filtering
    - [x] `test_get_candidates_jd_not_found` - 404 for invalid JD
    - [x] `test_get_candidates_jd_not_parsed` - 409 if parsing not complete
    - [x] `test_get_candidates_jd_parsing_failed` - 409 if parsing failed
    - [x] `test_get_candidates_empty_result` - Empty list when no CVs
    - [x] `test_get_candidates_unauthenticated` - 401 without auth
    - [x] `test_get_candidates_limit_capped_at_100` - Verify max limit
    - [x] `test_get_candidates_invalid_uuid` - 422 for invalid UUID

## Dev Notes

### Previous Story Insights (Stories 3.1, 3.2)

From Story 3.2 implementation:
- `JDParser` extracts `required_skills`, `nice_to_have_skills`, `min_experience_years`
- Parsed results stored in `parsed_requirements` JSONB field
- Skills are normalized using `SkillExtractor` from `skill_extractor.py`
- Parse status tracked: PENDING, PROCESSING, COMPLETED, FAILED

**[Source: docs/stories/3.2.story.md#Dev-Notes]**

### CV Analysis Data Structure

From `CVAnalysis` model (`backend/app/modules/ai/models.py`):
```python
class CVAnalysis:
    cv_id: UUID
    status: AnalysisStatus  # PENDING, PROCESSING, COMPLETED, FAILED
    ai_score: int | None  # Overall CV quality score
    ai_summary: str | None  # Text summary
    extracted_skills: list[str] | None  # Flat list of skills
    skill_categories: dict | None  # Skills by category: {"programming_languages": [...], ...}
    skill_breakdown: dict | None  # Detailed scoring breakdown
```

**[Source: backend/app/modules/ai/models.py:19-62]**

### Matching Algorithm Design

**Score Calculation (0-100):**

1. **Skill Match Score (70% weight):**
   - Required skill match: Each matched required skill contributes to score
   - Nice-to-have bonus: Each matched nice-to-have adds bonus points
   - Formula: `(matched_required / total_required) * 60 + (matched_nice / total_nice) * 10`

2. **Experience Score (30% weight):**
   - Meets or exceeds requirement: 100% of experience weight
   - Below requirement: Proportional score based on how close
   - Formula: `min(cv_years / required_years, 1.0) * 30`

3. **Final Score:** `skill_score + experience_score` (clamped to 0-100)

### API Response Schema

```json
{
  "items": [
    {
      "cv_id": "uuid",
      "match_score": 85,
      "breakdown": {
        "matched_skills": ["python", "fastapi", "postgresql"],
        "missing_skills": ["kubernetes"],
        "extra_skills": ["docker", "redis"],
        "skill_score": 55,
        "experience_score": 30,
        "experience_years": 4
      },
      "cv_summary": "Senior Python developer with 4 years experience..."
    }
  ],
  "total": 15,
  "limit": 20,
  "offset": 0
}
```

### File Locations

**Files to Create:**
```
backend/app/modules/jobs/
└── candidate_ranker.py    # NEW: CandidateRanker class

backend/tests/modules/jobs/
└── test_candidate_ranker.py  # NEW: Ranker unit tests
```

**Files to Modify:**
```
backend/app/modules/jobs/
├── schemas.py             # Add ranking schemas
├── services.py            # Add get_all_cv_analyses function
└── router.py              # Add /candidates endpoint

backend/tests/modules/jobs/
└── test_job_router.py     # Add candidates endpoint tests
```

**[Source: docs/architecture/source-tree.md]**

### Technical Constraints

1. **Performance:**
   - Use SQLAlchemy eager loading for CV analyses
   - Consider caching for frequently accessed JDs
   - Pagination is mandatory (default limit: 20)

2. **Authorization:**
   - Only JD owner can access candidates endpoint
   - 404 returned for non-existent or unauthorized JDs

3. **Error Handling:**
   - Return 400/409 if JD parsing not complete
   - Return empty list if no CVs available
   - Handle cases where CV analysis is pending/failed

**[Source: docs/architecture/coding-standards.md]**

### Dependencies

- **Story 3.3 depends on:**
  - Story 3.1 (JD Module Foundation) - **DONE**
  - Story 3.2 (JD Parsing) - **DONE**
  - Epic 2 (CV Analysis) - CV model with extracted_skills available

- **Stories that depend on 3.3:**
  - Story 3.6 (Candidate Results Frontend) - Displays ranking results

## Testing

### Backend Tests
- **Location:** `backend/tests/modules/jobs/`
- **Framework:** `pytest` with async support (`pytest-asyncio`)
- **Test Client:** `httpx.AsyncClient` for API tests

### Test Patterns

```python
# Example: test_candidate_ranker.py
import pytest
from app.modules.jobs.candidate_ranker import CandidateRanker

@pytest.fixture
def ranker():
    return CandidateRanker()

def test_calculate_skill_score_all_matched(ranker):
    required = ["python", "fastapi"]
    nice_to_have = ["docker"]
    cv_skills = ["python", "fastapi", "docker", "postgresql"]
    
    result = ranker._calculate_skill_score(required, nice_to_have, cv_skills)
    
    assert result["matched_skills"] == ["python", "fastapi", "docker"]
    assert result["missing_skills"] == []
    assert "postgresql" in result["extra_skills"]
    assert result["skill_score"] >= 70  # Full required + nice-to-have bonus

def test_calculate_experience_score_meets_requirement(ranker):
    score = ranker._calculate_experience_score(required_years=3, cv_years=4)
    assert score == 30.0  # Full 30% weight

def test_calculate_experience_score_below(ranker):
    score = ranker._calculate_experience_score(required_years=5, cv_years=3)
    assert score == 18.0  # 3/5 * 30 = 18
```

**[Source: docs/architecture/testing-strategy.md]**

## Change Log

| Date | Version | Description | Author |
| :--- | :--- | :--- | :--- |
| 2025-12-18 | 1.0 | Initial draft of Story 3.3 - Candidate Ranking Engine | Bob (Scrum Master) |
| 2025-12-18 | 1.1 | Implementation complete - 102 tests passing | James (Dev) |

## Dev Agent Record

### Agent Model Used
Claude Sonnet 4 (Anthropic)

### File List

**Created:**
- `backend/app/modules/jobs/candidate_ranker.py` - CandidateRanker class with match scoring
- `backend/tests/modules/jobs/test_candidate_ranker.py` - 31 unit tests for ranker

**Modified:**
- `backend/app/modules/jobs/schemas.py` - Added MatchBreakdownResponse, RankedCandidateResponse, RankedCandidateListResponse
- `backend/app/modules/jobs/router.py` - Added GET /jd/{jd_id}/candidates endpoint
- `backend/tests/modules/jobs/test_job_router.py` - Added 11 integration tests for candidates endpoint

### Completion Notes

1. **Scoring Algorithm:**
   - Skill score: 70% weight (60% required skills + 10% nice-to-have)
   - Experience score: 30% weight
   - Total score clamped to 0-100

2. **Test Coverage:**
   - 31 unit tests for CandidateRanker class
   - 11 integration tests for /candidates endpoint
   - Total 102 tests in jobs module passing

3. **Pagination & Filtering:**
   - Default limit: 20, max limit: 100
   - Offset for pagination
   - min_score filter (0-100)

4. **Error Handling:**
   - 404 for JD not found or wrong owner
   - 409 for JD parsing not complete (pending/failed)
   - Empty result when no CVs available

### Debug Log References
N/A - No significant debugging issues encountered.
